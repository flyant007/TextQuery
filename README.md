#面向对象程序设计
##文本查询程序
> ###程序设计和物理问题不同，物理上有绝对的不可能，但是程序设计没有哪一种方式是绝对不可能，只是说哪一种设计方式相对更好。
###继承设计的一个准则是
> 当一个类公有的继承另一个类时，派生类与基类是“**是一种（Is A）**”的关系。公有派生类的对象可以用在任何需要基类对象的地方。
###设计思路
* `TextQuery::query(string &word)`的查找是单词查询即查找一个指定单词`word`，如果逻辑非通过继承`TextQuery`而来的话，其查询就得按照这种单词查询的方式来执行，那么我们就要定义逻辑非所要查询的所有单词。很明显这一般是不可能的。对于逻辑或和逻辑与查询其查询的是两个对象与`TextQuery::query(string &word)`的单个单词查询也是不同的。
* 另外，查询结果的处理上，`TextQuery::query(string &word)`直接返回查询到的结果，但是逻辑非的查询返回结果需要取反查询语句。逻辑或和逻辑与的返回则需要包含两个结果值的合并。
* 通过上面的两点分析来看，逻辑与或非如果直接继承`TextQuery`类的话其查询操作与`TextQuery::query(string &word)`的操作差别很大，是兄弟关系，而不是继承关系。

#### 1. 综上所述我们将这几种不同的查询操作建模成相互独立的类:

 > * `WordQuery`
 > * `NotQuery`
 > * `OrQuery`
 > * `AndQuery`
 
这些类指包含两个操作：

> * `eval()`接受一个`TextQuery`对象，并返回一个`QueryResult`,使用给定的`TextQuery`对象查找与之匹配的行。
> * `rep()`，返回查询语句的string表示形式。`eval()`使用`rep()`创建一个用来返回结果的`QueryResult`。

以上这四个类共享同一个接口，所以定义一个抽象基类`Query_base`来表示该接口，把`eval()`和`rep()`定义为纯虚函数。


#### 2. 将层次关系隐藏与接口类中

> 用户层代码将只关注计算查询结果，而不关注查询体系，那么用户层将不会直接使用上面的类，而是使用下面的c++表达式来求值： `Query q = Query("fiery") & Query("bird") | Query("ls"); `。
> 根据这样的设计要求，我们定义一个`Query`接口类来负责**隐藏整个继承体系**。
> > `Query`类保存一个`Query_base`指针，该基类的指针可以绑定到其派生类对象上。用户通过`Query`对象的操作来间接的创建并处理`Query_base`对象。重载下面`&、|、~`运算符。

> > * &运算符生成一个绑定到新的`AndQuery`对象上的`Query`对象
> > * |运算符生成一个绑定到新的`OrQuery`对象上的`Query`对象
> > * ~运算符生成一个绑定到新的`NotQuery`对象上的`Query`对象
> > * 接受`string`参数的`Query`构造函数生成一个新的`WordQuery`对象



